<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Whiteboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #f0f0f0;
            touch-action: none;
        }
        
        #canvas {
            display: block;
            cursor: crosshair;
            background: white;
            touch-action: none;
        }
        
        .toolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 1000;
            user-select: none;
        }
        
        .color-picker {
            display: flex;
            gap: 8px;
        }
        
        .color-btn {
            width: 30px;
            height: 30px;
            border: 2px solid #ddd;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .color-btn:hover {
            transform: scale(1.1);
        }
        
        .color-btn.active {
            border-color: #333;
            transform: scale(1.2);
        }
        
        .size-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .size-slider {
            width: 80px;
        }
        
        .action-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background: #007AFF;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .action-btn:hover {
            background: #0056CC;
        }
        
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 12px;
            z-index: 1000;
        }
        
        .status.connected {
            color: #28a745;
        }
        
        .status.disconnected {
            color: #dc3545;
        }
        
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .zoom-btn:hover {
            background: #f8f9fa;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 2000;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="toolbar">
        <div class="color-picker">
            <div class="color-btn active" style="background: #000" data-color="#000000"></div>
            <div class="color-btn" style="background: #f00" data-color="#ff0000"></div>
            <div class="color-btn" style="background: #0f0" data-color="#00ff00"></div>
            <div class="color-btn" style="background: #00f" data-color="#0000ff"></div>
            <div class="color-btn" style="background: #ff0" data-color="#ffff00"></div>
            <div class="color-btn" style="background: #f0f" data-color="#ff00ff"></div>
            <div class="color-btn" style="background: #0ff" data-color="#00ffff"></div>
        </div>
        
        <div class="size-control">
            <label>Size</label>
            <input type="range" class="size-slider" min="1" max="50" value="5" id="brushSize">
            <span id="sizeValue">5px</span>
        </div>
        
        <button class="action-btn" id="clearBtn">Clear View</button>
    </div>
    
    <div class="status disconnected" id="status">Connecting...</div>
    
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomOut">-</button>
        <button class="zoom-btn" id="zoomIn">+</button>
        <button class="zoom-btn" id="resetView">âŒ‚</button>
    </div>

    <div class="loading" id="loading">Loading tiles...</div>

    <script>
        /**
         * Production Collaborative Whiteboard Frontend
         * 
         * Features:
         * - Infinite pan and zoom
         * - Real-time drawing synchronization
         * - On-demand tile loading
         * - Touch and mouse support
         * - Optimized rendering
         */

        // Constants
        const TILE_SIZE = 1000;
        const MAX_ZOOM = 5;
        const MIN_ZOOM = 0.1;
        const ZOOM_STEP = 0.1;
        const TILE_CACHE_SIZE = 50;
        const RECONNECT_DELAY = 1000;
        const PING_INTERVAL = 30000;

        /**
         * Main Whiteboard Application
         */
        class WhiteboardApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentColor = '#000000';
                this.currentSize = 5;
                this.isDrawing = false;
                this.lastPoint = null;
                
                // Transform state
                this.transform = {
                    x: 0,
                    y: 0,
                    scale: 1
                };
                
                // Managers
                this.networkManager = new NetworkManager(this);
                this.tileManager = new TileManager(this);
                this.inputManager = new InputManager(this);
                this.renderer = new WhiteboardRenderer(this);
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupControls();
                this.setupEventListeners();
                this.networkManager.connect();
                this.startRenderLoop();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.renderer.redraw();
            }
            
            setupControls() {
                // Color picker
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelector('.color-btn.active').classList.remove('active');
                        btn.classList.add('active');
                        this.currentColor = btn.dataset.color;
                    });
                });
                
                // Brush size
                const sizeSlider = document.getElementById('brushSize');
                const sizeValue = document.getElementById('sizeValue');
                sizeSlider.addEventListener('input', () => {
                    this.currentSize = parseInt(sizeSlider.value);
                    sizeValue.textContent = this.currentSize + 'px';
                });
                
                // Clear button
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.renderer.clearView();
                });
                
                // Zoom controls
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, ZOOM_STEP);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, -ZOOM_STEP);
                });
                
                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetView();
                });
            }
            
            setupEventListeners() {
                // Prevent default touch behaviors
                document.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
                document.addEventListener('touchend', e => e.preventDefault(), { passive: false });
                document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
            }
            
            startRenderLoop() {
                const renderFrame = () => {
                    this.renderer.render();
                    requestAnimationFrame(renderFrame);
                };
                renderFrame();
            }
            
            // Transform utilities
            screenToWorld(screenX, screenY) {
                return {
                    x: (screenX - this.transform.x) / this.transform.scale,
                    y: (screenY - this.transform.y) / this.transform.scale
                };
            }
            
            worldToScreen(worldX, worldY) {
                return {
                    x: worldX * this.transform.scale + this.transform.x,
                    y: worldY * this.transform.scale + this.transform.y
                };
            }
            
            zoomAt(screenX, screenY, delta) {
                const worldPoint = this.screenToWorld(screenX, screenY);
                const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, this.transform.scale + delta));
                
                if (newScale !== this.transform.scale) {
                    this.transform.scale = newScale;
                    
                    // Adjust translation to zoom at the specified point
                    this.transform.x = screenX - worldPoint.x * this.transform.scale;
                    this.transform.y = screenY - worldPoint.y * this.transform.scale;
                    
                    this.tileManager.updateVisibleTiles();
                }
            }
            
            resetView() {
                this.transform.x = 0;
                this.transform.y = 0;
                this.transform.scale = 1;
                this.tileManager.updateVisibleTiles();
            }
            
            // Drawing methods
            startDrawing(x, y) {
                this.isDrawing = true;
                this.lastPoint = { x, y };
                this.drawStroke(x, y);
            }
            
            continueDrawing(x, y) {
                if (!this.isDrawing || !this.lastPoint) return;
                
                // Interpolate points for smooth lines
                const dx = x - this.lastPoint.x;
                const dy = y - this.lastPoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const steps = Math.max(1, Math.floor(distance / 2));
                
                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const interpX = this.lastPoint.x + dx * t;
                    const interpY = this.lastPoint.y + dy * t;
                    this.drawStroke(interpX, interpY);
                }
                
                this.lastPoint = { x, y };
            }
            
            stopDrawing() {
                this.isDrawing = false;
                this.lastPoint = null;
            }
            
            drawStroke(x, y) {
                const stroke = {
                    x: x,
                    y: y,
                    color: this.currentColor,
                    size: this.currentSize
                };
                
                // Send to server
                this.networkManager.sendStroke(stroke);
                
                // Draw locally for immediate feedback
                this.renderer.drawStroke(stroke);
            }
            
            // Handle incoming strokes from server
            onStrokeReceived(stroke) {
                this.renderer.drawStroke(stroke);
                this.tileManager.addStrokeToCache(stroke);
            }
            
            // Handle tile data from server
            onTileReceived(tileData) {
                this.tileManager.storeTile(tileData);
                this.renderer.redraw();
            }
        }

        /**
         * Network Manager - handles WebSocket communication
         */
        class NetworkManager {
            constructor(app) {
                this.app = app;
                this.ws = null;
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 10;
                this.pingInterval = null;
            }
            
            connect() {
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = \`\${protocol}//\${window.location.host}\`;
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.updateStatus('Connected');
                        this.startPing();
                        
                        // Request initial visible tiles
                        this.app.tileManager.updateVisibleTiles();
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleMessage(message);
                        } catch (error) {
                            console.error('Message parse error:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        this.isConnected = false;
                        this.updateStatus('Disconnected');
                        this.stopPing();
                        this.attemptReconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateStatus('Connection Error');
                    };
                    
                } catch (error) {
                    console.error('Connection error:', error);
                    this.updateStatus('Connection Failed');
                    this.attemptReconnect();
                }
            }
            
            handleMessage(message) {
                switch (message.type) {
                    case 'stroke':
                        this.app.onStrokeReceived(message.data);
                        break;
                    case 'tileData':
                        this.app.onTileReceived(message.tile);
                        break;
                    case 'pong':
                        // Heartbeat response
                        break;
                    case 'error':
                        console.error('Server error:', message.message);
                        break;
                    default:
                        console.warn('Unknown message type:', message.type);
                }
            }
            
            sendStroke(stroke) {
                if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'stroke',
                        data: stroke
                    }));
                }
            }
            
            requestTiles(tiles) {
                if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'requestTiles',
                        tiles: tiles
                    }));
                }
            }
            
            startPing() {
                this.pingInterval = setInterval(() => {
                    if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({ type: 'ping' }));
                    }
                }, PING_INTERVAL);
            }
            
            stopPing() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
            }
            
            attemptReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    this.updateStatus(\`Reconnecting... (\${this.reconnectAttempts}/\${this.maxReconnectAttempts})\`);
                    
                    setTimeout(() => {
                        this.connect();
                    }, RECONNECT_DELAY * this.reconnectAttempts);
                } else {
                    this.updateStatus('Connection Failed - Refresh to retry');
                }
            }
            
            updateStatus(status) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = status;
                statusEl.className = 'status ' + (this.isConnected ? 'connected' : 'disconnected');
            }
        }

        /**
         * Tile Manager - handles tile loading and caching
         */
        class TileManager {
            constructor(app) {
                this.app = app;
                this.tileCache = new Map(); // tileKey -> { strokes: [], lastAccess: timestamp }
                this.loadedTiles = new Set();
                this.pendingTiles = new Set();
            }
            
            getTileKey(tileX, tileY) {
                return \`\${tileX}:\${tileY}\`;
            }
            
            getTileCoords(worldX, worldY) {
                return {
                    x: Math.floor(worldX / TILE_SIZE),
                    y: Math.floor(worldY / TILE_SIZE)
                };
            }
            
            getVisibleTiles() {
                const viewport = this.getViewport();
                const tiles = [];
                
                const startTileX = Math.floor(viewport.left / TILE_SIZE);
                const endTileX = Math.floor(viewport.right / TILE_SIZE);
                const startTileY = Math.floor(viewport.top / TILE_SIZE);
                const endTileY = Math.floor(viewport.bottom / TILE_SIZE);
                
                for (let tx = startTileX; tx <= endTileX; tx++) {
                    for (let ty = startTileY; ty <= endTileY; ty++) {
                        tiles.push({ x: tx, y: ty });
                    }
                }
                
                return tiles;
            }
            
            getViewport() {
                const topLeft = this.app.screenToWorld(0, 0);
                const bottomRight = this.app.screenToWorld(this.app.canvas.width, this.app.canvas.height);
                
                return {
                    left: topLeft.x,
                    top: topLeft.y,
                    right: bottomRight.x,
                    bottom: bottomRight.y
                };
            }
            
            updateVisibleTiles() {
                const visibleTiles = this.getVisibleTiles();
                const tilesToRequest = [];
                
                for (const tile of visibleTiles) {
                    const tileKey = this.getTileKey(tile.x, tile.y);
                    
                    if (!this.loadedTiles.has(tileKey) && !this.pendingTiles.has(tileKey)) {
                        tilesToRequest.push(tile);
                        this.pendingTiles.add(tileKey);
                    }
                }
                
                if (tilesToRequest.length > 0) {
                    this.app.networkManager.requestTiles(tilesToRequest);
                }
            }
            
            storeTile(tileData) {
                const tileKey = this.getTileKey(tileData.x, tileData.y);
                
                this.tileCache.set(tileKey, {
                    strokes: tileData.strokes || [],
                    lastAccess: Date.now()
                });
                
                this.loadedTiles.add(tileKey);
                this.pendingTiles.delete(tileKey);
                
                // Manage cache size
                if (this.tileCache.size > TILE_CACHE_SIZE) {
                    this.evictOldestTile();
                }
            }
            
            getTile(tileX, tileY) {
                const tileKey = this.getTileKey(tileX, tileY);
                const tile = this.tileCache.get(tileKey);
                
                if (tile) {
                    tile.lastAccess = Date.now();
                    return tile.strokes;
                }
                
                return [];
            }
            
            addStrokeToCache(stroke) {
                const tileCoords = this.getTileCoords(stroke.x, stroke.y);
                const tileKey = this.getTileKey(tileCoords.x, tileCoords.y);
                
                if (this.tileCache.has(tileKey)) {
                    const tile = this.tileCache.get(tileKey);
                    tile.strokes.push(stroke);
                    tile.lastAccess = Date.now();
                }
            }
            
            evictOldestTile() {
                let oldestKey = null;
                let oldestTime = Date.now();
                
                for (const [key, tile] of this.tileCache) {
                    if (tile.lastAccess < oldestTime) {
                        oldestTime = tile.lastAccess;
                        oldestKey = key;
                    }
                }
                
                if (oldestKey) {
                    this.tileCache.delete(oldestKey);
                    this.loadedTiles.delete(oldestKey);
                }
            }
        }

        /**
         * Input Manager - handles mouse and touch events
         */
        class InputManager {
            constructor(app) {
                this.app = app;
                this.isPanning = false;
                this.lastPanPoint = null;
                this.touches = new Map();
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                const canvas = this.app.canvas;
                
                // Mouse events
                canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                
                // Touch events
                canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                
                // Prevent context menu
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            // Mouse event handlers
            handleMouseDown(e) {
                e.preventDefault();
                const rect = this.app.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (e.button === 0) { // Left mouse button
                    const worldPoint = this.app.screenToWorld(x, y);
                    this.app.startDrawing(worldPoint.x, worldPoint.y);
                } else if (e.button === 2) { // Right mouse button
                    this.startPanning(x, y);
                }
            }
            
            handleMouseMove(e) {
                e.preventDefault();
                const rect = this.app.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.app.isDrawing) {
                    const worldPoint = this.app.screenToWorld(x, y);
                    this.app.continueDrawing(worldPoint.x, worldPoint.y);
                } else if (this.isPanning) {
                    this.continuePanning(x, y);
                }
            }
            
            handleMouseUp(e) {
                e.preventDefault();
                
                if (e.button === 0) {
                    this.app.stopDrawing();
                } else if (e.button === 2) {
                    this.stopPanning();
                }
            }
            
            handleWheel(e) {
                e.preventDefault();
                const rect = this.app.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
                this.app.zoomAt(x, y, delta);
            }
            
            // Touch event handlers
            handleTouchStart(e) {
                e.preventDefault();
                const rect = this.app.canvas.getBoundingClientRect();
                
                for (const touch of e.changedTouches) {
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    this.touches.set(touch.identifier, { x, y, startTime: Date.now() });
                }
                
                if (e.touches.length === 1) {
                    // Single touch - start drawing
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const worldPoint = this.app.screenToWorld(x, y);
                    this.app.startDrawing(worldPoint.x, worldPoint.y);
                } else if (e.touches.length === 2) {
                    // Two finger touch - start panning
                    this.app.stopDrawing();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                    const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
                    this.startPanning(centerX, centerY);
                }
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                const rect = this.app.canvas.getBoundingClientRect();
                
                if (e.touches.length === 1 && this.app.isDrawing) {
                    // Single touch - continue drawing
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const worldPoint = this.app.screenToWorld(x, y);
                    this.app.continueDrawing(worldPoint.x, worldPoint.y);
                } else if (e.touches.length === 2 && this.isPanning) {
                    // Two finger touch - continue panning
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                    const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
                    this.continuePanning(centerX, centerY);
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                
                for (const touch of e.changedTouches) {
                    this.touches.delete(touch.identifier);
                }
                
                if (e.touches.length === 0) {
                    this.app.stopDrawing();
                    this.stopPanning();
                }
            }
            
            // Panning utilities
            startPanning(x, y) {
                this.isPanning = true;
                this.lastPanPoint = { x, y };
                this.app.canvas.style.cursor = 'grab';
            }
            
            continuePanning(x, y) {
                if (!this.isPanning || !this.lastPanPoint) return;
                
                const dx = x - this.lastPanPoint.x;
                const dy = y - this.lastPanPoint.y;
                
                this.app.transform.x += dx;
                this.app.transform.y += dy;
                
                this.lastPanPoint = { x, y };
                this.app.tileManager.updateVisibleTiles();
            }
            
            stopPanning() {
                this.isPanning = false;
                this.lastPanPoint = null;
                this.app.canvas.style.cursor = 'crosshair';
            }
        }

        /**
         * Whiteboard Renderer - handles canvas drawing and optimization
         */
        class WhiteboardRenderer {
            constructor(app) {
                this.app = app;
                this.needsRedraw = true;
                this.strokeBuffer = [];
            }
            
            render() {
                if (this.needsRedraw) {
                    this.redraw();
                    this.needsRedraw = false;
                }
                
                // Draw buffered strokes
                if (this.strokeBuffer.length > 0) {
                    this.drawBufferedStrokes();
                    this.strokeBuffer = [];
                }
            }
            
            redraw() {
                const ctx = this.app.ctx;
                const canvas = this.app.canvas;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Set transform
                ctx.save();
                ctx.translate(this.app.transform.x, this.app.transform.y);
                ctx.scale(this.app.transform.scale, this.app.transform.scale);
                
                // Draw grid (optional)
                this.drawGrid();
                
                // Draw tiles
                this.drawVisibleTiles();
                
                ctx.restore();
            }
            
            drawGrid() {
                const ctx = this.app.ctx;
                const viewport = this.app.tileManager.getViewport();
                
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1 / this.app.transform.scale;
                
                // Draw tile boundaries
                const startX = Math.floor(viewport.left / TILE_SIZE) * TILE_SIZE;
                const endX = Math.ceil(viewport.right / TILE_SIZE) * TILE_SIZE;
                const startY = Math.floor(viewport.top / TILE_SIZE) * TILE_SIZE;
                const endY = Math.ceil(viewport.bottom / TILE_SIZE) * TILE_SIZE;
                
                ctx.beginPath();
                for (let x = startX; x <= endX; x += TILE_SIZE) {
                    ctx.moveTo(x, viewport.top);
                    ctx.lineTo(x, viewport.bottom);
                }
                for (let y = startY; y <= endY; y += TILE_SIZE) {
                    ctx.moveTo(viewport.left, y);
                    ctx.lineTo(viewport.right, y);
                }
                ctx.stroke();
            }
            
            drawVisibleTiles() {
                const visibleTiles = this.app.tileManager.getVisibleTiles();
                
                for (const tile of visibleTiles) {
                    const strokes = this.app.tileManager.getTile(tile.x, tile.y);
                    for (const stroke of strokes) {
                        this.drawSingleStroke(stroke);
                    }
                }
            }
            
            drawStroke(stroke) {
                // Add to buffer for next render
                this.strokeBuffer.push(stroke);
            }
            
            drawBufferedStrokes() {
                const ctx = this.app.ctx;
                
                ctx.save();
                ctx.translate(this.app.transform.x, this.app.transform.y);
                ctx.scale(this.app.transform.scale, this.app.transform.scale);
                
                for (const stroke of this.strokeBuffer) {
                    this.drawSingleStroke(stroke);
                }
                
                ctx.restore();
            }
            
            drawSingleStroke(stroke) {
                const ctx = this.app.ctx;
                
                ctx.fillStyle = stroke.color;
                ctx.beginPath();
                ctx.arc(stroke.x, stroke.y, stroke.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            clearView() {
                // Clear only the visible area, not the entire canvas data
                this.needsRedraw = true;
            }
        }

        // Initialize the application
        let app;
        
        document.addEventListener('DOMContentLoaded', () => {
            app = new WhiteboardApp();
        });

        // Handle visibility changes for performance
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // App is hidden, reduce activity
                if (app && app.networkManager) {
                    app.networkManager.stopPing();
                }
            } else {
                // App is visible, resume activity
                if (app && app.networkManager && app.networkManager.isConnected) {
                    app.networkManager.startPing();
                }
            }
        });
    </script>
</body>
</html>
